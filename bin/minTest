#!/usr/bin/env python

import math
import time
from scipy.optimize import least_squares
import pickle

import cv2
import numpy as np
import rospy
from cv_bridge import CvBridge
from front_end.motion import *
from front_end.simulation import *
from sensor_msgs.msg import CameraInfo, Image
from tf.transformations import quaternion_from_euler, quaternion_matrix


def withinROI(cameraConfig,pt):
    if((pt[0]>0)and(pt[0]<cameraConfig["width"])):
        if((pt[1]>0)and(pt[1]<cameraConfig["height"])):
            return True
        else:
            return False
    else:
        return False

def genStereoLandmark(cameraConfig,H):
        validPoint=False
        while(not validPoint):
            simPoint={}
            x=np.random.normal(0,5,1)
            y=np.random.normal(0,5,1)
            z=np.random.normal(0,4,1)
            Point=np.ones((4,1),dtype=np.float64)

            simPoint["Xa"]=copy.deepcopy(Point)
            simPoint["Xa"][0,0]=x
            simPoint["Xa"][1,0]=y
            simPoint["Xa"][2,0]=z
            simPoint["La"]=cameraConfig["Pl"].dot(simPoint["Xa"])
            simPoint["La"]=simPoint["La"]/simPoint["La"][2,0]
            simPoint["Ra"]=cameraConfig["Pr"].dot(simPoint["Xa"])
            simPoint["Ra"]=simPoint["Ra"]/simPoint["Ra"][2,0]

            simPoint["Xb"]=np.dot(H,simPoint["Xa"])
            simPoint["Xb"]=simPoint["Xb"]/simPoint["Xb"][3,0]
            simPoint["Lb"]=cameraConfig["Pl"].dot(simPoint["Xb"])
            simPoint["Lb"]=simPoint["Lb"]/simPoint["Lb"][2,0]
            simPoint["Rb"]=cameraConfig["Pr"].dot(simPoint["Xb"])
            simPoint["Rb"]=simPoint["Rb"]/simPoint["Rb"][2,0]
            if(withinROI(cameraConfig,simPoint["La"])and withinROI(cameraConfig,simPoint["Lb"])
                and withinROI(cameraConfig,simPoint["Ra"]) and withinROI(cameraConfig,simPoint["Rb"])
                and (simPoint["Xa"][2,0]>0) and (simPoint["Xb"][2,0]>0)
                and (simPoint["Xa"][1,0]>-0.5) and (simPoint["Xb"][1,0]>-0.5)):
                validPoint=True
                simPoint["XaPred"]=cv2.triangulatePoints(cameraConfig["Pl"],cameraConfig["Pr"],
                                    (simPoint["La"][0,0],simPoint["La"][1,0]),
                                    (simPoint["Ra"][0,0],simPoint["Ra"][1,0]))
                simPoint["XaPred"]/=simPoint["XaPred"][3,0]
                simPoint["XbPred"]=cv2.triangulatePoints(cameraConfig["Pl"],cameraConfig["Pr"],
                                    (simPoint["Lb"][0,0],simPoint["Lb"][1,0]),
                                    (simPoint["Rb"][0,0],simPoint["Rb"][1,0]))
                simPoint["XaQPred"]=stereo3DProject(simPoint["La"],simPoint["Ra"],cameraConfig["Q"])
                simPoint["XbQPred"]=stereo3DProject(simPoint["Lb"],simPoint["Rb"],cameraConfig["Q"])
        return simPoint

rospy.init_node('minTest')
cvb=CvBridge()

kSettings=getCameraSettingsFromServer()
mSettings=MotionCategorySettings()
NisterSettings=genDefaultNisterSettings(kSettings)

idealR = noisyRotations(mSettings["Slow"]["RotationNoise"])
Tc=dominantTranslation(mSettings["Slow"]["TranslationMean"],mSettings["Slow"]["TranslationNoise"])


Htransform= composeTransform(idealR["matrix"],
                                            Tc["vector"])          
print("original")
print(idealR)
print(Tc)
print(Htransform)
print("---")


totalPoints=200
data=[]

for i in range(0,totalPoints):
    data.append(genStereoLandmark(kSettings,Htransform))
ans=10

errorVector=np.zeros((totalPoints,1),dtype=np.float64)


def composeCam(R,T):
    P=np.zeros((3,4),dtype=np.float64)
    P[0:3,0:3]=R
    P[0:3,3]=T 
    P= kSettings["k"].dot(P)
    return P


def error(x, *args, **kwargs):
    q=quaternion_from_euler(x[0],x[1],x[2],'szxy')
    Rest=quaternion_matrix(q)[0:3,0:3]  
    T=x[3:]
    Ht=createHomog(Rest,T)
    print(Ht)
    totalRMS=0
    index=0
    Pb=composeCam(Rest,T)
    for i in data:
        newPixel=Pb.dot(i["Xa"])
        newPixel= newPixel/newPixel[2,0]
        e= abs(i["Lb"][0,0]-newPixel[0,0])+abs(i["Lb"][1,0]-newPixel[1,0])
        totalRMS+=e
        index+=1
    #print(x)
    #print(x[0,:])  
    #H=createHomog(Rest,np[])    
    return totalRMS#np.array([ans-x[0],0,0,0,0,0])

ans=least_squares(error,np.array([0,0,0,0,0,0]),verbose=True,max_nfev=1500)
print(ans.x)
print(Tc)
print(getMotion(decomposeTransform(Htransform)))
print("roll",math.degrees(ans.x[0]))
print("pitch",math.degrees(ans.x[1]))
print("yaw",math.degrees(ans.x[2]))
print(ans.x[3])
print(ans.x[4])
print(ans.x[5])