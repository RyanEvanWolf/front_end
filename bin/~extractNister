#!/usr/bin/env python

import math
import time

import pickle

import cv2
import numpy as np
import rospy
from cv_bridge import CvBridge
from front_end.motion import *
from front_end.simulation import *
from sensor_msgs.msg import CameraInfo, Image
from tf.transformations import quaternion_from_euler, quaternion_matrix
import bumblebee.utils as butil

import argparse
rospy.init_node('NisterSimulation')
cvb=CvBridge()


parser =argparse.ArgumentParser()
parser.add_argument("root_dir",help="The absolute directory to the motion simulation directory",type=str)
parser.add_argument("--type",help="The type of motion simulation, either straight or steering",
                    default="straight",type=str)
args,unknown=parser.parse_known_args()

cameraSettings=butil.getPickledObject(args.root_dir+"/camera.p")


NisterSettings=genDefaultNisterSettings(cameraSettings)

f=open(args.root_dir+"/Nister.p","w")
pickle.dump(NisterSettings,f)
f.close()

NisterExtractor=cvExtract("/media/ryan/EXTRA/output/Simulation",NisterSettings)


simulationFiles=os.listdir(args.root_dir+"/Slow/"+args.type+"/Data")
####
outDirectory=args.root_dir+"/Slow/"+args.type+"/Nister"

################
###slow simulation
################

for hFile in simulationFiles:
    currentFileDir=args.root_dir+"/Slow/"+args.type+"/Data/"+hFile
    outDirectory=args.root_dir+"/Slow/"+args.type+"/Nister"
    currentFile=butil.getPickledObject(currentFileDir)
    ###gen Ideal data
    for operatingLvL in currentFile["OperatingCurves"]:
        #####
        ##get the Points associated with each operating curve
        currentPoints=[]
        previousPoints=[]
        currentLandmarks=[]
        previousLandmarks=[]
        for pointIndex in operatingLvL[0]:
            selectedSimPoint=currentFile["Points"][pointIndex]
            currentPoints.append([selectedSimPoint.Data["Lb"][0,0],
                                selectedSimPoint.Data["Lb"][1,0]]) 
            currentLandmarks.append(selectedSimPoint.Data["Xb"]) 
            previousPoints.append([selectedSimPoint.Data["La"][0,0],
                    selectedSimPoint.Data["La"][1,0]])  
            previousLandmarks.append(selectedSimPoint.Data["Xa"])
        c=NisterExtractor.extractScaledMotion(currentPoints,currentLandmarks,
                                        previousPoints,previousLandmarks,True)
        outFile=outDirectory+"/ideal_"+str(len(operatingLvL[0])).zfill(5)+".p"
        if(not os.path.exists(outDirectory)):
            os.makedirs(outDirectory)
        
        f=open(outFile,"w")
        pickle.dump(c,f)
        f.close()        
        print(outFile)
        print(getMotion(currentFile["H"]),"Original")
        print(getUnitTranslation(currentFile["H"]))
        # print(getMotion(currentFile["H"]),"Original")
        # print(getMotion(decomposeTransform(c["H"])),"nister")
#                 print(getMotion(IdealData["H"]),"ideal")
#                 print(getMotion(decomposeTransform(c["H"])),"nister")
#                 print(getMotion(decomposeTransform(s["H"])),"rigid")
#                 print(compareAbsoluteMotion(IdealData["H"],decomposeTransform(c["H"])),"abserr")
#                 print(compareAbsoluteMotion(IdealData["H"],decomposeTransform(s["H"])),"abserr2")
    print("--")
# c,m,n=d.getSettings()

# K=c["Pl"][0:3,0:3]
# f=open(args.root_dir+"/Nister.p", 'r')
# NisterSettings=pickle.load(f)
# f.close()

# NisterExtractor=nisterExtract("/media/ryan/EXTRA/output/Simulation",NisterSettings)
# pcl=pclExtract("/media/ryan/EXTRA/output/Simulation",NisterSettings)
# cvE=cvExtract("/media/ryan/EXTRA/output/Simulation",NisterSettings)
# ####################
# ###extract Slow Noisy Data

# ind=d.getOutlierDir()[0]
# ideal=d.getIdealWorldDir()[0]
# def extractDir(inDir,idealDir):
#     print(inDir)
#     levels=os.listdir(inDir)
#     for lvl in levels:
#         #####
#         worldFilesSet=os.listdir(inDir+"/"+lvl)
#         for Hpickle in worldFilesSet:
#             f=open(inDir+"/"+lvl+"/"+Hpickle,"r")
#             simulationData=pickle.load(f)
#             f.close()  
#             f=open(idealDir+"/"+Hpickle,"r")
#             IdealData=pickle.load(f)
#             f.close()
#             print(inDir+"/"+lvl+"/"+Hpickle)
#             print(idealDir+"/"+Hpickle)
#             print(simulationData.keys())
#             for name in simulationData:
#                 curpts,prvpts,curLand,prevLand=packPoints(simulationData[name]["Pts"])
#                 s=pcl.rigid_transform_3D(prevLand,curLand)
#                 c=cvE.extractScaledMotion(curpts,curLand,prvpts,prevLand,True)
#                 simulationData[name]["nisterResult"]=c
#                 simulationData[name]["rigidResult"]=s
#                 print(getMotion(IdealData["H"]),"ideal")
#                 print(getMotion(decomposeTransform(c["H"])),"nister")
#                 print(getMotion(decomposeTransform(s["H"])),"rigid")
#                 print(compareAbsoluteMotion(IdealData["H"],decomposeTransform(c["H"])),"abserr")
#                 print(compareAbsoluteMotion(IdealData["H"],decomposeTransform(s["H"])),"abserr2")
#             # outData=[]
#             # outData={}
#             # outData["nisterResult"]=[]
#             # outData["rigidResult"]=[]
#             # for curve in data:
#             #     currentPoints=[]
#             #     previousPoints=[]
#             #     currentLandmarks=[]
#             #     previousLandmarks=[]
#             #     for point in curve:
#             #         currentPoints.append([point["Lb"][0,0],point["Lb"][1,0]])
#             #         currentLandmarks.append(point["Xb"])
#             #         previousPoints.append([point["La"][0,0],point["La"][1,0]])
#             #         previousLandmarks.append(point["Xa"])
#             #     r=cvE.extractScaledMotion(currentPoints,currentLandmarks,previousPoints,previousLandmarks,True)
#             #     #print(len(curve),r["nInliers"],getMotion(decomposeTransform(np.linalg.inv(r["H"]))))
#             #     s=pcl.rigid_transform_3D(previousLandmarks,currentLandmarks)
#             #     print(getMotion(IdealData["H"]),"ideal")
#             #     print(getMotion(decomposeTransform(r["H"])),"nister")
#             #     print(getMotion(decomposeTransform(s["H"])),"rigid")
#             #     print(compareAbsoluteMotion(IdealData["H"],decomposeTransform(s["H"])),"abserr")
#             #     print(compareAbsoluteMotion(IdealData["H"],decomposeTransform(r["H"])),"abserr2")
#             #     outData["rigidResult"].append(s)
#             #     outData["nisterResult"].append(r)
#             newFile=cvE.root+"/extracted"+inDir[inDir.rfind("/"):]+"/"+lvl
#             if(not os.path.exists(newFile)):
#                 os.makedirs(newFile)
#             newFile+="/"+Hpickle
#             print(newFile)
#             f=open(newFile,"w")
#             pickle.dump(simulationData,f)
#             f.close()

# extractDir(ind,ideal)



# ind=d.getOutlierDir()[1]
# ideal=d.getIdealWorldDir()[1]
# extractDir(ind,ideal)

# ind=d.getOutlierDir()[1]
# ideal=d.getIdealWorldDir()[1]
# extractDir(ind,ideal)
# #####
# ###get all the different variations

#         # print(getMotion(data["H"]),"ideal")
#         # for curve in data["Curves"]:
#         #     ###get each Curve ID and pack it into a list
#         #     currentPoints=[]
#         #     previousPoints=[]
#         #     currentLandmarks=[]
#         #     previousLandmarks=[]
#         #     curveID=str(len(curve))

#         #     for pointIndex in curve:
#         #         currentPoints.append([data["Points"][pointIndex]["Lb"][0,0],data["Points"][pointIndex]["Lb"][1,0]])
#         #         currentLandmarks.append(data["Points"][pointIndex]["Xb"])
#         #         previousPoints.append([data["Points"][pointIndex]["La"][0,0],data["Points"][pointIndex]["La"][1,0]])
#         #         previousLandmarks.append(data["Points"][pointIndex]["Xa"])
                

#         #     r=NisterExtractor.extractScaledMotion(currentPoints,currentLandmarks,previousPoints,previousLandmarks,True)
#         #     pickleOut
#         #     f=open(self.output+"/"+inputFolder+"/"+Hpickle,"w")
#         #     pickle.dump(HResults,f)
#         #     f.close()
#         #     print(getMotion(decomposeTransform(r["H"])),"measured")
#         #     print(compareMotion(data["H"],decomposeTransform(r["H"])),"percent")
#         # print("---")
 
