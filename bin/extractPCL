#!/usr/bin/env python

import math
import time

import pickle

import cv2
import numpy as np
import rospy
from cv_bridge import CvBridge
from front_end.motion import *
from front_end.simulation import *
from sensor_msgs.msg import CameraInfo, Image
from tf.transformations import quaternion_from_euler, quaternion_matrix
import bumblebee.utils as butil
import os 
import argparse
rospy.init_node('NisterSimulation')
cvb=CvBridge()

parser =argparse.ArgumentParser()
parser.add_argument("root_dir",help="The absolute directory to the motion simulation directory",type=str)
parser.add_argument("--type",help="The type of motion simulation, either straight or steering",
                    default="straight",type=str)
args,unknown=parser.parse_known_args()

cameraSettings=butil.getPickledObject(args.root_dir+"/camera.p")

ba=BAextractor(cameraSettings)


simulationFiles=os.listdir(args.root_dir+"/Slow/"+args.type+"/Data")
####
outDirectory=args.root_dir+"/Slow/"+args.type+"/PCL"

NisterSettings=genDefaultNisterSettings(cameraSettings)

pclExtractor=pclExtract("/media/ryan/EXTRA/output/Simulation",NisterSettings)

################
###slow simulation
################

for hFile in simulationFiles:
    currentFileDir=args.root_dir+"/Slow/"+args.type+"/Data/"+hFile
    outDirectory=args.root_dir+"/Slow/"+args.type+"/BA"
    currentFile=butil.getPickledObject(currentFileDir)
    ###gen Ideal data
    for operatingLvL in currentFile["OperatingCurves"]:
        #####
        ##get the Points associated with each operating curve
        currentPoints=[]
        previousPoints=[]
        currentLandmarks=[]
        previousLandmarks=[]
        for pointIndex in operatingLvL[0]:
            selectedSimPoint=currentFile["Points"][pointIndex]
            currentPoints.append([selectedSimPoint.Data["Lb"][0,0],
                                selectedSimPoint.Data["Lb"][1,0]]) 
            currentLandmarks.append(selectedSimPoint.Data["Xb"]) 
            previousPoints.append([selectedSimPoint.Data["La"][0,0],
                    selectedSimPoint.Data["La"][1,0]])  
            previousLandmarks.append(selectedSimPoint.Data["Xa"])
        estimate=pclExtractor.rigid_transform_3D(currentLandmarks,previousLandmarks)
        print(getMotion(currentFile["H"]),"Original")
        print(getMotion(decomposeTransform(np.linalg.inv(estimate["H"]))),"est")
        outFile=outDirectory+"/ideal_"+str(len(operatingLvL[0])).zfill(5)+".p"
        if(not os.path.exists(outDirectory)):
            os.makedirs(outDirectory)
        
        f=open(outFile,"w")
        pickle.dump(estimate,f)
        f.close()        
        print(outFile)





# ind=d.getOutlierDir()[0]
# ideal=d.getIdealWorldDir()[0]
# def extractDir(inDir,idealDir):
#     print(inDir)
#     levels=os.listdir(inDir)
#     for lvl in levels:
#         #####
#         worldFilesSet=os.listdir(inDir+"/"+lvl)
#         for Hpickle in worldFilesSet:
#             f=open(inDir+"/"+lvl+"/"+Hpickle,"r")
#             data=pickle.load(f)
#             f.close()  
#             f=open(idealDir+"/"+Hpickle,"r")
#             IdealData=pickle.load(f)
#             f.close()
#             print(inDir+"/"+lvl+"/"+Hpickle)
#             print(idealDir+"/"+Hpickle)
#             print(getMotion(IdealData["H"]),"ideal")
#             outData=[]
#             for curve in data:
#                 currentPoints=[]
#                 previousPoints=[]
#                 currentLandmarks=[]
#                 previousLandmarks=[]
#                 for point in curve:
#                     currentPoints.append([point["Lb"][0,0],point["Lb"][1,0]])
#                     currentLandmarks.append(point["Xb"])
#                     previousPoints.append([point["La"][0,0],point["La"][1,0]])
#                     previousLandmarks.append(point["Xa"])
#                 r=pclExtractor.closedForm(currentLandmarks,previousLandmarks)
#                 print(getMotion(np.linalg.inv(r)))
#                 print(getMotion(decomposeTransform(r)),"ttt")


# extractDir(ind,ideal)


 
